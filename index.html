<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-03-08 Wed 20:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>eliza-cl.org</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="benrudgers" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">eliza-cl.org</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdfb680a">Preface</a></li>
<li><a href="#org6edd54a">Introduction</a></li>
<li><a href="#org76adc42">System</a>
<ul>
<li><a href="#org546941b">:eliza package</a></li>
</ul>
</li>
<li><a href="#org6c8d4fd">Pattern Matching</a>
<ul>
<li><a href="#org1a5e185">simple-equal</a></li>
<li><a href="#orgf34be5c">variable-p</a></li>
<li><a href="#org9c67cc5">pat-match</a>
<ul>
<li><a href="#org820b59f">A naive version</a></li>
<li><a href="#org4f1148f">A second buggy version</a></li>
<li><a href="#org22fff8a">pattern matching constants</a></li>
<li><a href="#org378d69a">abstractions over assoc</a></li>
<li><a href="#org775916f">A third version</a></li>
<li><a href="#org7736ad0">Segment Pattern Matching</a></li>
<li><a href="#org776ecc9">Final</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgdfb680a" class="outline-2">
<h2 id="orgdfb680a">Preface</h2>
<div class="outline-text-2" id="text-orgdfb680a">
<p>
<b><b>The computer code here is not original to me.</b></b> and this document reflects several of my ongoing projects:
</p>
<ol class="org-ol">
<li>Learning 'classic' AI by working through Peter Norvig's <a href="http://norvig.com/paip.html"><b>Paradigms of Artificial Intelligence: Case Studies in Common Lisp</b></a>.   Norvig's book is the source for the Lisp code in this project.</li>
<li>Learning more Emacs in general and org-mode in particular.</li>
<li>Developing a work process around Literate Programming.</li>
</ol>
</div>
</div>
<div id="outline-container-org6edd54a" class="outline-2">
<h2 id="org6edd54a">Introduction</h2>
</div>
<div id="outline-container-org76adc42" class="outline-2">
<h2 id="org76adc42">System</h2>
<div class="outline-text-2" id="text-org76adc42">
<p>
This is my first attempt at using ASDF to build a system. The system uses utility files available <a href="https://github.com/brudgers/norvig-utils">here</a>.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(load "../utils/norvig-utils")
(load "../utils/norvig-debugger")

(defpackage #:eliza
  (:use :common-lisp
        :asdf
        :norvig-utils
        :norvig-debugger
        :kludgecode))

(in-package :eliza)

(defsystem eliza
    :serial t
    :components ((:file "eliza")))
</pre>
</div>
</div>
<div id="outline-container-org546941b" class="outline-3">
<h3 id="org546941b">:eliza package</h3>
<div class="outline-text-3" id="text-org546941b">
<p>
As is the case with ASDF, this is also my first time developing using Common Lisp's package system.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org9a60c8e">(in-package :eliza)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6c8d4fd" class="outline-2">
<h2 id="org6c8d4fd">Pattern Matching</h2>
<div class="outline-text-2" id="text-org6c8d4fd">
</div><div id="outline-container-org1a5e185" class="outline-3">
<h3 id="org1a5e185">simple-equal</h3>
<div class="outline-text-3" id="text-org1a5e185">
<div class="org-src-container">
<pre class="src src-lisp">(defun simple-equal (x y)
  "Are x and y equal. Does not check inside strings."
  (if (or (atom x) (atom y))
      (eql x y)
      (and (simple-equal (first x) (first y))
           (simple-equal (rest x) (rest y)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf34be5c" class="outline-3">
<h3 id="orgf34be5c">variable-p</h3>
<div class="outline-text-3" id="text-orgf34be5c">
<p>
This function brings up two interesting aspects of Common Lisp. The first is that <code>atom</code>'s are not truely atomic. The second is that predicate syntax in Common Lisp suffers from the same big-language inconsistencies as might be found in PHP.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org69b903e">(defun variable-p (x)
  "Is x a variable where a variable is a symbol beginning with '?'"
  (and (symbolp x)
       (equal (char (symbol-name x) 0)
              #\?)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9c67cc5" class="outline-3">
<h3 id="org9c67cc5">pat-match</h3>
<div class="outline-text-3" id="text-org9c67cc5">
<p>
The naive version is so straight forward it could be template code for recursing on a list (or two lists). There is a certain concision to the first part which avoids enumerating all the cases of atoms and lists. Though it arises more from the template style than anything else. 
</p>
</div>
<div id="outline-container-org820b59f" class="outline-4">
<h4 id="org820b59f">A naive version</h4>
<div class="outline-text-4" id="text-org820b59f">
<div class="org-src-container">
<pre class="src src-lisp">(defun pat-match (input pattern)
  "Does pattern match input? Any variable can match anything."
  (if (variable-p pattern)
      t
      (if (or (atom pattern) (atom input))
          (eql pattern input)
          (and (pat-match (first input) (first pattern))
               (pat-match (rest input) (rest pattern))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4f1148f" class="outline-4">
<h4 id="org4f1148f">A second buggy version</h4>
<div class="outline-text-4" id="text-org4f1148f">
<p>
One problem is that <code>(eql pattern input)</code> may return <code>t</code>. While <code>nil</code> is not a problem for <code>append</code>, <code>t</code> is&#x2026;since <code>t</code> is not a list. Booleans are actually tough if they're overloaded as they are many languages.
</p>

<p>
The second problem is semi-boolean contexts: those in which <code>nil</code> may be returned from a successful match versus where <code>nil</code> is returned because a predicate turned out to be false. Did I say booleans are tough?
</p>

<p>
The final problem is that we want the same variable (e.g. <code>?X</code>) to consistently be bound to the same expression when it appears multiple times in an input.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun pat-match (pattern input)
  "BUGGY Second version."
  (if (variable-p pattern)
      (list (cons pattern input))
      (if (or (atom pattern) (atom input))
          (eql pattern input)
          (append (pat-match (first pattern) (first input))
                  (pat-match (rest pattern) (rest input))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org22fff8a" class="outline-4">
<h4 id="org22fff8a">pattern matching constants</h4>
<div class="outline-text-4" id="text-org22fff8a">
<p>
The first step in the third version is to turn <code>pat-match</code> into a true predicate that only returns <code>nil</code> for failure. It's worth noting that only having a single value that indicates <code>false</code> is helpful here.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org427021e">(defconstant fail nil "indicates pat-match failure.")

(defconstant no-bindings '(t . t)
  "Indicates a pattern match success, with no variables.")
</pre>
</div>
</div>
</div>
<div id="outline-container-org378d69a" class="outline-4">
<h4 id="org378d69a">abstractions over assoc</h4>
<div class="outline-text-4" id="text-org378d69a">
<p>
<b>Note:</b> The ASDF build system loads these from my <a href="https://github.com/brudgers/norvig-utils">norvig-utils repository</a>. They are shown here to maintain consistency with the text.
</p>

<p>
Building abstractions over <code>assoc</code> enables using the language of variables and bindings rather than low level lisp.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org2474b75">(defun get-bindings (var bindings)
  "Find a (variable . value) pair in a binding list."
  (assoc var bindings))

(defun binding-val (binding)
  "Get the value part of a single binding."
  (cdr binding))

(defun lookup (var bindings)
  "Get the value part (for var) from a binding list."
  (binding-val (get-bindings var bindings)))

(defun extend-bindings (var val bindings)
  "Add a (var . value) pair to a binding list."
  (cons (cons var val) bindings))
</pre>
</div>
</div>
</div>
<div id="outline-container-org775916f" class="outline-4">
<h4 id="org775916f">A third version</h4>
<div class="outline-text-4" id="text-org775916f">
<p>
There are five cases for <code>pat-match</code>:
</p>
<ol class="org-ol">
<li>Bindings list is <code>fail</code> and the match fails.</li>
<li>Pattern is a single variable.</li>
<li>Pattern and input are <code>eql</code>.</li>
<li>Pattern and input are both lists.</li>
<li>None of these holds and the match fails.</li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(defun pat-match (pattern input &amp;optional (bindings non-bindings))
  "Match pattern against input in the context of bindings."
  (cond ((eq bindings fail) fail)
        ((variable-p pattern)
         (match-variable pattern input bindings))
        ((eql pattern input) bindings)
        ((and (consp pattern)
              (consp input))
         (pat-match (rest pattern)
                    (rest input)
                    (pat-match (first pattern)
                               (first input)
                               bindings)))
        (t fail)))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp" id="orgdd02266">(defun match-variable (var input bindings)
  "Does var match input. Uses bindings. Returns bindings with or without an update depending on match."
  (let ((binding (get-bindings var bindings)))
    (cond ((not binding) (extend-bindings var input bindings))
          ((equal input (binding-val binding)) bindings)
          (t fail))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org7736ad0" class="outline-4">
<h4 id="org7736ad0">Segment Pattern Matching</h4>
<div class="outline-text-4" id="text-org7736ad0">
<p>
It is useful to have two types of variables, those that match individual input elements and others that behave like Lisp's <code>&amp;rest</code> parameter. The latter can be thought of as matching segments. This would allow a syntax such as <code>(?P need . ?X)</code>.
</p>
<div class="org-src-container">
<pre class="src src-lisp">;;; Example
(pat-match '((?* ?p) need (?* ?x))
           '(Mr Hulot and I need a vaction))
((?P MR HULOT AND I) (?X A VACTION))
</pre>
</div>
<p>
Updating <code>pat-match</code> for the new behavior:
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="orgabd8753">(defun pat-match (pattern input &amp;optional (bindings no-bindings))
  "Match pattern against input in context of the bindings."
  (cond ((eq bindings fail) fail)
        ((variable-p pattern)
         (match-variable pattern input bindings))
        ((eql pattern input) bindings)
        ((segment-pattern-p pattern)
         (segment-match pattern input bindings))
        ((and (consp pattern) (consp input))
         (pat-match (rest pattern)
                    (rest input)
                    (pat-match (first pattern)
                               (first input)
                               bindings)))
        (t fail)))
</pre>
</div>
<p>
Adding the new predicate highlights Common Lisp's flexibility in regards to naming symbols by allowing a notation evocative of the kleene star.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org52d726f">(defun segment-pattern-p (pattern)
  "Is this a segment matching pattern: ((?* var) . pat)"
  (and (consp pattern)
       (starts-with (first pattern) '?*)))
</pre>
</div>
<p>
The first pass at <code>segment-match</code> address the problems that arise when the next element of the pattern is contained in the input but there are intervening elements between what has been matched already and the match for the next element of the pattern. It allows looking further ahead in the input at the expense of requiring a segment-variable to be the last variable in a pattern.
</p>
<div class="org-src-container">
<pre class="src src-lisp" id="org9619acf">(defun segment-match (pattern input bindings &amp;optional (start 0))
  "Match the segment patter ((?* var) . pat) against input."
  (let ((var (second (first pattern)))
        (pat (rest pattern)))
    (if (null pat)
        (match-variable var input bindings)
        ;; We assume pat starts with a constant
        ;; In other words, a pattern can't have 2 consectutive vars
        (let ((pos (position (first pat)
                             input
                             :start start
                             :test #'equal)))
          (if (null pos)
              fail
              (let ((b2 (pat-match (subseq input pos)
                                   bindings)))
                ;; If this match failed try another longer one
                ;; If it worked, check that the variables match
                (if (eq b2 fail)
                    (segment-match pattern input bindings (+ 1 pos))
                    (match-variable var
                                    (subseq input 0 pos)
                                    b2))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org776ecc9" class="outline-4">
<h4 id="org776ecc9">Final</h4>
<div class="outline-text-4" id="text-org776ecc9">
<div class="org-src-container">
<pre class="src src-lisp" id="orgbaf76af">&lt;&lt;eliza-package&gt;&gt;

&lt;&lt;pat-match-constants&gt;&gt;

&lt;&lt;binding-utilities&gt;&gt;

&lt;&lt;variable-p&gt;&gt;

&lt;&lt;match-variable&gt;&gt;

&lt;&lt;pat-match&gt;&gt;

&lt;&lt;segment-match&gt;&gt;

&lt;&lt;segment-pattern-p&gt;&gt;
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: benrudgers</p>
<p class="date">Created: 2017-03-08 Wed 20:26</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
